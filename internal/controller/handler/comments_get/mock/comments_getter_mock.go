package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"
	"web_lab/internal/models"

	"github.com/gojuno/minimock/v3"
)

// CommentsGetterMock implements comments_get.commentsGetter
type CommentsGetterMock struct {
	t minimock.Tester

	funcGetComments          func(ctx context.Context) (ca1 []models.Comment, err error)
	inspectFuncGetComments   func(ctx context.Context)
	afterGetCommentsCounter  uint64
	beforeGetCommentsCounter uint64
	GetCommentsMock          mCommentsGetterMockGetComments
}

// NewCommentsGetterMock returns a mock for comments_get.commentsGetter
func NewCommentsGetterMock(t minimock.Tester) *CommentsGetterMock {
	m := &CommentsGetterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCommentsMock = mCommentsGetterMockGetComments{mock: m}
	m.GetCommentsMock.callArgs = []*CommentsGetterMockGetCommentsParams{}

	return m
}

type mCommentsGetterMockGetComments struct {
	mock               *CommentsGetterMock
	defaultExpectation *CommentsGetterMockGetCommentsExpectation
	expectations       []*CommentsGetterMockGetCommentsExpectation

	callArgs []*CommentsGetterMockGetCommentsParams
	mutex    sync.RWMutex
}

// CommentsGetterMockGetCommentsExpectation specifies expectation struct of the commentsGetter.GetComments
type CommentsGetterMockGetCommentsExpectation struct {
	mock    *CommentsGetterMock
	params  *CommentsGetterMockGetCommentsParams
	results *CommentsGetterMockGetCommentsResults
	Counter uint64
}

// CommentsGetterMockGetCommentsParams contains parameters of the commentsGetter.GetComments
type CommentsGetterMockGetCommentsParams struct {
	ctx context.Context
}

// CommentsGetterMockGetCommentsResults contains results of the commentsGetter.GetComments
type CommentsGetterMockGetCommentsResults struct {
	ca1 []models.Comment
	err error
}

// Expect sets up expected params for commentsGetter.GetComments
func (mmGetComments *mCommentsGetterMockGetComments) Expect(ctx context.Context) *mCommentsGetterMockGetComments {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("CommentsGetterMock.GetComments mock is already set by Set")
	}

	if mmGetComments.defaultExpectation == nil {
		mmGetComments.defaultExpectation = &CommentsGetterMockGetCommentsExpectation{}
	}

	mmGetComments.defaultExpectation.params = &CommentsGetterMockGetCommentsParams{ctx}
	for _, e := range mmGetComments.expectations {
		if minimock.Equal(e.params, mmGetComments.defaultExpectation.params) {
			mmGetComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetComments.defaultExpectation.params)
		}
	}

	return mmGetComments
}

// Inspect accepts an inspector function that has same arguments as the commentsGetter.GetComments
func (mmGetComments *mCommentsGetterMockGetComments) Inspect(f func(ctx context.Context)) *mCommentsGetterMockGetComments {
	if mmGetComments.mock.inspectFuncGetComments != nil {
		mmGetComments.mock.t.Fatalf("Inspect function is already set for CommentsGetterMock.GetComments")
	}

	mmGetComments.mock.inspectFuncGetComments = f

	return mmGetComments
}

// Return sets up results that will be returned by commentsGetter.GetComments
func (mmGetComments *mCommentsGetterMockGetComments) Return(ca1 []models.Comment, err error) *CommentsGetterMock {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("CommentsGetterMock.GetComments mock is already set by Set")
	}

	if mmGetComments.defaultExpectation == nil {
		mmGetComments.defaultExpectation = &CommentsGetterMockGetCommentsExpectation{mock: mmGetComments.mock}
	}
	mmGetComments.defaultExpectation.results = &CommentsGetterMockGetCommentsResults{ca1, err}
	return mmGetComments.mock
}

// Set uses given function f to mock the commentsGetter.GetComments method
func (mmGetComments *mCommentsGetterMockGetComments) Set(f func(ctx context.Context) (ca1 []models.Comment, err error)) *CommentsGetterMock {
	if mmGetComments.defaultExpectation != nil {
		mmGetComments.mock.t.Fatalf("Default expectation is already set for the commentsGetter.GetComments method")
	}

	if len(mmGetComments.expectations) > 0 {
		mmGetComments.mock.t.Fatalf("Some expectations are already set for the commentsGetter.GetComments method")
	}

	mmGetComments.mock.funcGetComments = f
	return mmGetComments.mock
}

// When sets expectation for the commentsGetter.GetComments which will trigger the result defined by the following
// Then helper
func (mmGetComments *mCommentsGetterMockGetComments) When(ctx context.Context) *CommentsGetterMockGetCommentsExpectation {
	if mmGetComments.mock.funcGetComments != nil {
		mmGetComments.mock.t.Fatalf("CommentsGetterMock.GetComments mock is already set by Set")
	}

	expectation := &CommentsGetterMockGetCommentsExpectation{
		mock:   mmGetComments.mock,
		params: &CommentsGetterMockGetCommentsParams{ctx},
	}
	mmGetComments.expectations = append(mmGetComments.expectations, expectation)
	return expectation
}

// Then sets up commentsGetter.GetComments return parameters for the expectation previously defined by the When method
func (e *CommentsGetterMockGetCommentsExpectation) Then(ca1 []models.Comment, err error) *CommentsGetterMock {
	e.results = &CommentsGetterMockGetCommentsResults{ca1, err}
	return e.mock
}

// GetComments implements comments_get.commentsGetter
func (mmGetComments *CommentsGetterMock) GetComments(ctx context.Context) (ca1 []models.Comment, err error) {
	mm_atomic.AddUint64(&mmGetComments.beforeGetCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetComments.afterGetCommentsCounter, 1)

	if mmGetComments.inspectFuncGetComments != nil {
		mmGetComments.inspectFuncGetComments(ctx)
	}

	mm_params := &CommentsGetterMockGetCommentsParams{ctx}

	// Record call args
	mmGetComments.GetCommentsMock.mutex.Lock()
	mmGetComments.GetCommentsMock.callArgs = append(mmGetComments.GetCommentsMock.callArgs, mm_params)
	mmGetComments.GetCommentsMock.mutex.Unlock()

	for _, e := range mmGetComments.GetCommentsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetComments.GetCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetComments.GetCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetComments.GetCommentsMock.defaultExpectation.params
		mm_got := CommentsGetterMockGetCommentsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetComments.t.Errorf("CommentsGetterMock.GetComments got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetComments.GetCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetComments.t.Fatal("No results are set for the CommentsGetterMock.GetComments")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetComments.funcGetComments != nil {
		return mmGetComments.funcGetComments(ctx)
	}
	mmGetComments.t.Fatalf("Unexpected call to CommentsGetterMock.GetComments. %v", ctx)
	return
}

// GetCommentsAfterCounter returns a count of finished CommentsGetterMock.GetComments invocations
func (mmGetComments *CommentsGetterMock) GetCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComments.afterGetCommentsCounter)
}

// GetCommentsBeforeCounter returns a count of CommentsGetterMock.GetComments invocations
func (mmGetComments *CommentsGetterMock) GetCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComments.beforeGetCommentsCounter)
}

// Calls returns a list of arguments used in each call to CommentsGetterMock.GetComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetComments *mCommentsGetterMockGetComments) Calls() []*CommentsGetterMockGetCommentsParams {
	mmGetComments.mutex.RLock()

	argCopy := make([]*CommentsGetterMockGetCommentsParams, len(mmGetComments.callArgs))
	copy(argCopy, mmGetComments.callArgs)

	mmGetComments.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsDone returns true if the count of the GetComments invocations corresponds
// the number of defined expectations
func (m *CommentsGetterMock) MinimockGetCommentsDone() bool {
	for _, e := range m.GetCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCommentsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComments != nil && mm_atomic.LoadUint64(&m.afterGetCommentsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCommentsInspect logs each unmet expectation
func (m *CommentsGetterMock) MinimockGetCommentsInspect() {
	for _, e := range m.GetCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsGetterMock.GetComments with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCommentsCounter) < 1 {
		if m.GetCommentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CommentsGetterMock.GetComments")
		} else {
			m.t.Errorf("Expected call to CommentsGetterMock.GetComments with params: %#v", *m.GetCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComments != nil && mm_atomic.LoadUint64(&m.afterGetCommentsCounter) < 1 {
		m.t.Error("Expected call to CommentsGetterMock.GetComments")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentsGetterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCommentsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentsGetterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentsGetterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCommentsDone()
}
